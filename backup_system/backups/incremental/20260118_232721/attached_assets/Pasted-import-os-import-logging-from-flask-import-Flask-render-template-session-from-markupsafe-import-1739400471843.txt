import os
import logging
from flask import Flask, render_template, session
from markupsafe import Markup
from flask_login import LoginManager
from flask_migrate import Migrate
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import text
import secrets
from dotenv import load_dotenv
from flask_mail import Mail
from extensions import db
import json
from functools import wraps
from datetime import datetime

# Load environment variables from .env file
load_dotenv()

# Configure logging with more detailed format
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize extensions without binding to app yet
login_manager = LoginManager()
migrate = Migrate()
mail = Mail()

def nl2br(value):
    """Convert newlines to HTML line breaks"""
    if not value:
        return ""
    return Markup(value.replace('\n', '<br>\n'))

def verify_deployment_integrity():
    """Verify critical deployment configurations and dependencies"""
    try:
        # Verify essential environment variables
        required_vars = ['DATABASE_URL', 'FLASK_SECRET_KEY']
        missing_vars = [var for var in required_vars if not os.environ.get(var)]
        if missing_vars:
            logger.error(f"[DEPLOYMENT] Missing required environment variables: {', '.join(missing_vars)}")
            return False

        # Verify Google Maps API key if present
        maps_api_key = os.environ.get('GOOGLE_MAPS_API_KEY')
        if maps_api_key:
            if len(maps_api_key) < 20:  # Basic validation for API key format
                logger.warning("[DEPLOYMENT] Google Maps API key appears to be invalid")
            else:
                logger.info("[DEPLOYMENT] Google Maps API key validated")
        else:
            logger.warning("[DEPLOYMENT] Google Maps API key not found")

        # Verify database connection
        try:
            with db.engine.connect() as conn:
                conn.execute(text('SELECT 1'))
            logger.info("[DEPLOYMENT] Database connection verified")
        except Exception as e:
            logger.error(f"[DEPLOYMENT] Database connection failed: {e}")
            return False

        logger.info("[DEPLOYMENT] All deployment checks passed successfully")
        return True
    except Exception as e:
        logger.error(f"[DEPLOYMENT] Deployment verification failed: {e}")
        return False

def deployment_check(f):
    """Decorator to check deployment integrity before running critical features"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not verify_deployment_integrity():
            return render_template('500.html', error="Deployment verification failed"), 500
        return f(*args, **kwargs)
    return decorated_function

def create_app(test_config=None):
    """Application factory function with improved error handling and logging"""
    try:
        logger.info("[APP_INIT] Starting Flask application creation...")
        app = Flask(__name__, static_folder='static', template_folder='templates')

        if test_config is None:
            # Configure from environment variables
            secret_key = os.environ.get('FLASK_SECRET_KEY')
            if not secret_key:
                secret_key = secrets.token_hex(32)
                os.environ['FLASK_SECRET_KEY'] = secret_key
            app.config['SECRET_KEY'] = secret_key
            logger.debug("[APP_INIT] Secret key configured")

            # Database URL configuration
            database_url = os.environ.get("DATABASE_URL")
            if not database_url:
                logger.error("[APP_INIT] DATABASE_URL environment variable not set")
                raise ValueError("DATABASE_URL environment variable not set")

            # Configure database
            app.config['SQLALCHEMY_DATABASE_URI'] = database_url
            app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
            app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
                "pool_pre_ping": True,
                "pool_recycle": 300,
                "pool_size": 10,
                "max_overflow": 20
            }
            logger.debug("[APP_INIT] Database configuration completed")

        else:
            app.config.update(test_config)

        # Register nl2br filter globally before initializing extensions
        app.jinja_env.filters['nl2br'] = nl2br

        # Initialize extensions with app
        logger.info("[APP_INIT] Initializing Flask extensions...")
        db.init_app(app)
        login_manager.init_app(app)
        migrate.init_app(app, db)
        mail.init_app(app)

        with app.app_context():
            try:
                # Test database connection
                logger.info("[APP_INIT] Testing database connection...")
                db.session.execute(text('SELECT 1'))
                db.session.commit()
                logger.info("[APP_INIT] Database connection test successful")

                # Import models to create tables
                import models  # noqa: F401

                # Create tables if they don't exist
                db.create_all()
                logger.info("[APP_INIT] Database tables created/verified")

                # Import and register blueprints
                logger.info("[APP_INIT] Registering blueprints...")
                from auth import auth_bp
                from chat import chat_bp
                from food_tracker import food_tracker_bp
                from dashboard import dashboard_bp
                from ring_routes import ring_bp
                from cbt import cbt_bp
                from journal import journal_bp
                from forum import forum
                from location_wellness import location_wellness
                from health_prediction import health_prediction_bp
                from wellness_toolbox import wellness_toolbox_bp
                from challenge_routes import challenges_bp
                from stress_monitoring import stress_bp
                from fasting import fasting_bp

                blueprints = [
                    (auth_bp, "Authentication"),
                    (chat_bp, "Chat"),
                    (food_tracker_bp, "Food Tracker"),
                    (dashboard_bp, "Dashboard"),
                    (ring_bp, "Ring Integration"),
                    (cbt_bp, "CBT"),
                    (journal_bp, "Journal"),
                    (forum, "Forum"),
                    (location_wellness, "Location Wellness", "/location-wellness"),
                    (health_prediction_bp, "Health Prediction"),
                    (wellness_toolbox_bp, "Wellness Toolbox"),
                    (challenges_bp, "Meditation Challenges"),
                    (stress_bp, "Stress Monitoring"),
                    (fasting_bp, "Fasting Programs")
                ]

                for blueprint_info in blueprints:
                    blueprint = blueprint_info[0]
                    name = blueprint_info[1]
                    url_prefix = blueprint_info[2] if len(blueprint_info) > 2 else None

                    try:
                        if url_prefix:
                            app.register_blueprint(blueprint, url_prefix=url_prefix)
                        else:
                            app.register_blueprint(blueprint)
                        logger.info(f"[APP_INIT] Registered {name} blueprint successfully")
                    except Exception as e:
                        logger.error(f"[APP_INIT] Failed to register {name} blueprint: {e}")
                        raise

                @app.route('/')
                def index():
                    return render_template('index.html')

                # Configure session
                @app.before_request
                def before_request():
                    session.permanent = True

                logger.info("[APP_INIT] Flask application created and configured successfully")
                return app

            except SQLAlchemyError as e:
                logger.error(f"[APP_INIT] Database error during application initialization: {e}")
                raise
            except Exception as e:
                logger.error(f"[APP_INIT] Error during application initialization: {e}")
                raise

    except Exception as e:
        logger.error(f"[APP_INIT] Fatal error during application creation: {e}")
        raise

# Create the application instance
app = create_app()

@login_manager.user_loader
def load_user(user_id):
    """Load user by ID for Flask-Login"""
    try:
        from models import User
        return User.query.get(int(user_id))
    except Exception as e:
        logger.error(f"[AUTH] Error loading user {user_id}: {e}")
        return None

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)